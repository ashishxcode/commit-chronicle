#!/usr/bin/env zsh

# Monthly Development Report Generator
# Cross-platform script for Windows (Git Bash/WSL), Linux, and macOS
# Uses only git and gh commands to generate markdown report
# Optimized for zsh shell

# Function to generate commit chronicle report
commit_chronicle() {
    # Save current directory to return to it later
    local ORIGINAL_DIR="$PWD"
    
    # Trap to ensure we return to original directory on exit
    trap 'cd "$ORIGINAL_DIR"' EXIT

set -e

# Enable zsh array compatibility
setopt KSH_ARRAYS  # Use 0-based array indexing like bash
setopt POSIX_ARGZERO  # Set $0 to script name like bash

# Detect operating system
detect_os() {
    case "$(uname -s)" in
        CYGWIN*|MINGW*|MSYS*)
            echo "windows"
            ;;
        Linux*)
            echo "linux" 
            ;;
        Darwin*)
            echo "macos"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

OS_TYPE=$(detect_os)

# Cross-platform absolute path resolution
get_absolute_path() {
    local path="$1"
    if [ "$OS_TYPE" = "windows" ]; then
        # Handle Windows paths in Git Bash/MSYS2
        if [[ "$path" =~ ^[A-Za-z]: ]]; then
            # Already absolute Windows path
            echo "$path"
        elif [[ "$path" = /* ]]; then
            # Unix-style absolute path in Git Bash
            echo "$path"
        else
            # Relative path
            echo "$(cd "$path" 2>/dev/null && pwd)" || echo ""
        fi
    else
        # Linux/macOS
        if [[ "$path" = /* ]]; then
            echo "$path"
        else
            echo "$(cd "$path" 2>/dev/null && pwd)" || echo ""
        fi
    fi
}

# Cross-platform line count (handle different wc implementations)
count_lines() {
    if [ "$OS_TYPE" = "linux" ]; then
        wc -l | sed 's/^[ \t]*//' | cut -d' ' -f1
    else
        wc -l | tr -d ' '
    fi
}

# Error handling function
handle_error() {
    local error_message="$1"
    local error_code="${2:-1}"
    echo "‚ùå ERROR: $error_message" >&2
    echo "üí° Try running with debugging: bash -x $0" >&2
    exit $error_code
}

# Validate prerequisites
validate_prerequisites() {
    # Check if git is installed
    if ! command -v git &> /dev/null; then
        handle_error "Git is not installed. Please install Git and try again."
    fi
    
    # Check if we have at least one valid repository
    if [ ${#REPO_PATHS[@]} -eq 0 ]; then
        handle_error "No valid Git repositories found. Please check your repository paths."
    fi
}

# Validate user input
validate_input() {
    local month="$1"
    local author="$2"
    local username="$3"
    
    if [[ ! $month =~ ^[0-9]{4}-[0-9]{2}$ ]]; then
        handle_error "Invalid month format '$month'. Use YYYY-MM (e.g., 2024-08)"
    fi
    
    if [ -z "$author" ]; then
        handle_error "Author name cannot be empty"
    fi
    
    if [ -z "$username" ]; then
        handle_error "GitHub username cannot be empty"
    fi
}

# Start timing
START_TIME=$(date +%s)

echo "üìã Monthly Development Report Generator"
echo "========================================"
echo "üñ•Ô∏è  Platform: $OS_TYPE ($(uname -s))"
echo "‚è±Ô∏è  Started: $(date +"%Y-%m-%d %H:%M:%S")"
echo ""

# Interactive input collection
echo -n "üìÖ Enter month (YYYY-MM) [$(date +"%Y-%m")]: "
read MONTH_INPUT
MONTH=${MONTH_INPUT:-$(date +"%Y-%m")}

echo -n "üë§ Enter your full name [Ashish Patel]: "
read AUTHOR_INPUT
AUTHOR=${AUTHOR_INPUT:-"Ashish Patel"}

echo -n "üêô Enter GitHub username [ashishxcode]: "
read GITHUB_USERNAME_INPUT
GITHUB_USERNAME=${GITHUB_USERNAME_INPUT:-"ashishxcode"}

# Validate input
validate_input "$MONTH" "$AUTHOR" "$GITHUB_USERNAME"

# Create comprehensive author patterns for git log matching
# This handles various name/email combinations and case variations
create_author_pattern() {
    local author_name="$1"
    local github_username="$2"
    
    # Build a regex pattern that matches common author variations
    # Include: exact name, email patterns with username, case variations
    echo "($author_name|${github_username}@|${github_username}.*@|.*${github_username}.*)"
}


# Parse branch references to extract clean branch names
parse_branch_name() {
    local branch_refs="$1"
    # Extract the main branch name from git references like "origin/feature/ABC-123-description"
    # Remove origin/, HEAD ->, and other git reference prefixes
    echo "$branch_refs" | sed -E 's/.*(origin\/|HEAD -> )//g' | sed 's/,.*//g' | sed 's/^ *//g'
}

# Find branches where user has pushed commits during the date range
find_user_branches() {
    local repo_path="$1"
    local author="$2"
    local start_date="$3"
    local end_date="$4"
    
    cd "$repo_path"
    
    # Get all branches that contain commits by the user in the date range
    # This includes both local and remote branches
    local user_branches=$(git for-each-ref --format='%(refname:short)' refs/heads/ refs/remotes/ | while read branch; do
        # Check if this branch has commits by the user in our date range
        local commit_count=$(git log "$branch" --author="$author" --regexp-ignore-case --since="$start_date" --until="$end_date" --oneline 2>/dev/null | wc -l | tr -d ' ')
        if [ "$commit_count" -gt 0 ]; then
            # Clean up branch name (remove origin/ prefix)
            echo "$branch" | sed 's/origin\///g' | sed 's/remotes\/origin\///g'
        fi
    done | sort -u)
    
    echo "$user_branches"
}

# Get the most likely branch where user worked on this commit
get_user_work_branch() {
    local commit_hash="$1"
    local repo_path="$2"
    local user_branches="$3"
    
    cd "$repo_path"
    
    # First, try to find which user branch contains this commit
    echo "$user_branches" | while read branch; do
        if [ -n "$branch" ] && git merge-base --is-ancestor "$commit_hash" "$branch" 2>/dev/null; then
            # This branch contains the commit - check if it's not just main/master
            if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
                echo "$branch"
                return
            fi
        fi
    done
    
    # Fallback to original branch detection logic
    get_original_branch "$commit_hash" "$repo_path"
}

# Get the original branch name for a commit using git name-rev
get_original_branch() {
    local commit_hash="$1"
    local repo_path="$2"
    
    # Try multiple methods to get the original branch
    cd "$repo_path"
    
    # Method 1: Use git name-rev to find the branch tip this commit was part of
    local branch_name=$(git name-rev --name-only --refs="refs/heads/*" "$commit_hash" 2>/dev/null | sed 's/~.*//g' | sed 's/\^.*//g')
    
    # Method 2: If that fails, try to find branches that contain this commit (excluding main/master)
    if [ -z "$branch_name" ] || [ "$branch_name" = "main" ] || [ "$branch_name" = "master" ]; then
        branch_name=$(git branch --contains "$commit_hash" --all 2>/dev/null | grep -v -E "(main|master)" | grep -E "(origin/|remotes/)" | head -1 | sed 's/.*origin\///g' | sed 's/^ *//g' | sed 's/remotes\/origin\///g')
    fi
    
    # Method 3: If still no good branch, look at the commit subject for branch indicators
    if [ -z "$branch_name" ] || [ "$branch_name" = "main" ] || [ "$branch_name" = "master" ]; then
        local commit_message=$(git log -1 --pretty=format:"%s" "$commit_hash" 2>/dev/null)
        # Look for branch patterns in PR merge messages like "Merge pull request #123 from user/branch-name"
        branch_name=$(echo "$commit_message" | sed -n 's/.*from [^\/]*\/\([^)]*\).*/\1/p')
        
        # Look for patterns like "FEAT: something (#PR)" and extract from the hash
        if [ -z "$branch_name" ]; then
            local pr_number=$(echo "$commit_message" | sed -n 's/.*#\([0-9]*\).*/\1/p')
            if [ -n "$pr_number" ] && command -v gh &> /dev/null; then
                branch_name=$(gh pr view "$pr_number" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
            fi
        fi
    fi
    
    # Clean up the branch name
    branch_name=$(echo "$branch_name" | sed 's/origin\///g' | sed 's/remotes\///g' | sed 's/^ *//g' | sed 's/ *$//g')
    
    # If we still don't have a good branch name, default to main
    if [ -z "$branch_name" ] || [ "$branch_name" = "undefined" ]; then
        branch_name="main"
    fi
    
    echo "$branch_name"
}

# ==========================================
# üìÅ REPOSITORY CONFIGURATION
# ==========================================
# Configure your repository paths here. Edit this section to add your repositories.
# Use absolute paths for best results, or relative paths from where you run the script.

# Example configurations:
# REPO_PATHS=(
#     "/Users/username/projects/repo1"
#     "/Users/username/projects/repo2" 
#     "../other-project"
# )

# Configured repositories - edit these paths as needed
REPO_PATHS=(
    "/Users/ashish/work/forked/cx-saas-dashboard"
    "/Users/ashish/work/forked/cx-saas-server"
)

# If no repositories configured, use current working directory
if [ ${#REPO_PATHS[@]} -eq 0 ]; then
    CURRENT_ABS_PATH=$(get_absolute_path ".")
    if [ -d "$CURRENT_ABS_PATH/.git" ]; then
        REPO_PATHS+=("$CURRENT_ABS_PATH")
        echo "üìÇ Using current directory: $CURRENT_ABS_PATH"
    else
        echo "‚ùå Current directory is not a git repository"
        echo "üí° Either run this script from a git repository or configure REPO_PATHS in the script"
        exit 1
    fi
else
    # Validate configured repositories
    VALID_REPOS=()
    for REPO_PATH in "${REPO_PATHS[@]}"; do
        ABS_PATH=$(get_absolute_path "$REPO_PATH")
        if [ -z "$ABS_PATH" ]; then
            echo "‚ö†Ô∏è  Invalid path: $REPO_PATH (skipping)"
            continue
        fi
        
        if [ ! -d "$ABS_PATH/.git" ]; then
            echo "‚ö†Ô∏è  Not a git repository: $ABS_PATH (skipping)"
            continue
        fi
        
        VALID_REPOS+=("$ABS_PATH")
        echo "‚úÖ Found repository: $ABS_PATH"
    done
    
    if [ ${#VALID_REPOS[@]} -eq 0 ]; then
        echo "‚ùå No valid git repositories found in configuration"
        exit 1
    fi
    
    REPO_PATHS=("${VALID_REPOS[@]}")
fi

# Validate prerequisites after repository setup
validate_prerequisites

# Validate month format
if [[ ! $MONTH =~ ^[0-9]{4}-[0-9]{2}$ ]]; then
    echo "‚ùå Invalid month format. Use YYYY-MM (e.g., 2025-07)"
    exit 1
fi

# Parse month for date range
YEAR=$(echo $MONTH | cut -d'-' -f1)
MONTH_NUMBER=$(echo $MONTH | cut -d'-' -f2)
START_DATE="${YEAR}-${MONTH_NUMBER}-01"

# Calculate last day of month correctly (accounts for Feb, 30-day months, etc.)
if [ "$OS_TYPE" = "macos" ]; then
    # macOS date command
    END_DATE=$(date -j -v1d -v+1m -v-1d -f "%Y-%m-%d" "${YEAR}-${MONTH_NUMBER}-01" "+%Y-%m-%d" 2>/dev/null)
else
    # Linux date command
    END_DATE=$(date -d "${YEAR}-${MONTH_NUMBER}-01 +1 month -1 day" "+%Y-%m-%d" 2>/dev/null)
fi

# Fallback to day 31 if date calculation fails
if [ -z "$END_DATE" ]; then
    END_DATE="${YEAR}-${MONTH_NUMBER}-31"
fi

# Get month name
case $MONTH_NUMBER in
    01) MONTH_NAME="January" ;;
    02) MONTH_NAME="February" ;;
    03) MONTH_NAME="March" ;;
    04) MONTH_NAME="April" ;;
    05) MONTH_NAME="May" ;;
    06) MONTH_NAME="June" ;;  
    07) MONTH_NAME="July" ;;
    08) MONTH_NAME="August" ;;
    09) MONTH_NAME="September" ;;
    10) MONTH_NAME="October" ;;
    11) MONTH_NAME="November" ;;
    12) MONTH_NAME="December" ;;
esac

echo ""
echo "üìä Generating report for:"
echo "   Month: $MONTH_NAME $YEAR ($START_DATE to $END_DATE)"
echo "   Author: $AUTHOR"
echo "   GitHub: $GITHUB_USERNAME"
echo "   Repositories: ${#REPO_PATHS[@]} repo(s)"
for repo in "${REPO_PATHS[@]}"; do
    echo "     - $(basename "$repo") ($repo)"
done
echo "----------------------------------------"

# Output markdown file - create in Downloads directory (cross-platform)
get_downloads_dir() {
    case "$OS_TYPE" in
        "windows")
            # Windows: Use USERPROFILE/Downloads
            if [ -n "$USERPROFILE" ]; then
                echo "$USERPROFILE/Downloads"
            else
                echo "."
            fi
            ;;
        *)
            # Linux/macOS: Use HOME/Downloads
            echo "$HOME/Downloads"
            ;;
    esac
}

# Sanitize filename components
sanitize_filename() {
    local input="$1"
    # Remove/replace invalid characters: < > : " | ? * \ / and control chars
    echo "$input" | sed 's/[<>:"|?*\\\/[:cntrl:]]\+/_/g' | sed 's/__*/_/g' | sed 's/^_\|_$//g'
}

DOWNLOADS_DIR=$(get_downloads_dir)
# Test write permission and create directory with fallback
if ! mkdir -p "$DOWNLOADS_DIR" 2>/dev/null; then
    echo "‚ö†Ô∏è  Cannot create Downloads directory, using current directory"
    DOWNLOADS_DIR="."
elif ! touch "$DOWNLOADS_DIR/.test_write" 2>/dev/null; then
    echo "‚ö†Ô∏è  No write permission to Downloads directory, using current directory"
    DOWNLOADS_DIR="."
else
    rm -f "$DOWNLOADS_DIR/.test_write" 2>/dev/null
fi

# Sanitize filename components and create report path
CLEAN_MONTH=$(sanitize_filename "$MONTH_NAME")
CLEAN_YEAR=$(sanitize_filename "$YEAR")
CLEAN_USERNAME=$(sanitize_filename "$GITHUB_USERNAME")
REPORT_FILENAME="${CLEAN_MONTH}_${CLEAN_YEAR}_${CLEAN_USERNAME}_report.md"

# Set report file path
REPORT_FILE="$DOWNLOADS_DIR/$REPORT_FILENAME"

# Start building the markdown report
cat > "$REPORT_FILE" << EOF
# üìä Monthly Development Report - $MONTH_NAME $YEAR

> **Developer:** $AUTHOR  
> **GitHub Username:** \`$GITHUB_USERNAME\`  
> **Reporting Period:** \`$START_DATE\` to \`$END_DATE\`  
> **Generated:** $(date +"%B %d, %Y at %H:%M")

---

## üîÑ Pull Request Reviews

EOF

# Get GitHub repository URL
get_github_url() {
    local repo_path="$1"
    cd "$repo_path"
    local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
    
    if [ -n "$remote_url" ]; then
        # Convert SSH to HTTPS format and remove .git suffix
        echo "$remote_url" | sed 's/git@github.com:/https:\/\/github.com\//' | sed 's/\.git$//'
    fi
}

# Create GitHub commit link if possible
create_commit_link() {
    local commit_hash="$1"
    local repo_path="$2"
    local github_url=$(get_github_url "$repo_path")
    
    if [ -n "$github_url" ]; then
        echo "${github_url}/commit/${commit_hash}"
    fi
}

# Extract commit type from message (feat, fix, chore, etc.)
get_commit_type() {
    local message="$1"
    local type=$(echo "$message" | grep -oiE '^(feat|fix|chore|docs|style|refactor|perf|test|build|ci|revert|hotfix)' | tr '[:upper:]' '[:lower:]')
    if [ -n "$type" ]; then
        echo "$type"
    else
        echo "other"
    fi
}

# Progress indicator function
show_progress() {
    local step="$1"
    local total="$2"
    local message="$3"
    local percent=$((step * 100 / total))
    local filled=$((percent / 5))
    local empty=$((20 - filled))
    
    printf "\rüîÑ Progress: ["
    printf "%*s" $filled | tr ' ' '‚ñà'
    printf "%*s" $empty | tr ' ' '‚ñë'
    printf "] %d%% - %s" $percent "$message"
    
    if [ $step -eq $total ]; then
        echo ""
    fi
}

# Cross-platform temporary file creation
create_temp_file() {
    local suffix="$1"
    if [ "$OS_TYPE" = "windows" ]; then
        # Windows temp directory handling
        local temp_dir="${TEMP:-${TMP:-/tmp}}"
        local temp_file="$temp_dir/commit_chronicle_$$_$(date +%s)_${suffix}"
        touch "$temp_file" 2>/dev/null || {
            echo "‚ùå Failed to create temp file: $temp_file" >&2
            exit 1
        }
        echo "$temp_file"
    else
        # Use zsh-compatible mktemp
        mktemp -t "commit_chronicle_${suffix}.XXXXXX" 2>/dev/null || {
            # Fallback for systems without mktemp
            local temp_file="/tmp/commit_chronicle_$$_$(date +%s)_${suffix}"
            touch "$temp_file"
            echo "$temp_file"
        }
    fi
}

# Extract PR reviews first
echo "üîÑ Extracting PR reviews..."

if command -v gh &> /dev/null; then
    echo "### PRs Reviewed by Me" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"

    # Get PRs reviewed by user with comprehensive search including all review types
    TEMP_REVIEWED=$(create_temp_file "reviewed")

    # Search for PRs where user participated in reviews from all configured repositories
    # gh pr list requires repository context, so we iterate through repos
    for REPO_PATH in "${REPO_PATHS[@]}"; do
        cd "$REPO_PATH"
        REPO_NAME=$(basename "$REPO_PATH")

        # Method 1: PRs where user was explicitly listed as reviewer (approved reviews)
        gh pr list --search "reviewed-by:$GITHUB_USERNAME" \
            --limit 100 --state all --json number,title,state,reviews \
            2>/dev/null | jq -r ".[] | @base64" 2>/dev/null | while read -r pr_base64; do
                if [ -z "$pr_base64" ]; then
                    continue
                fi

                pr_json=$(echo "$pr_base64" | base64 -d 2>/dev/null)
                if [ $? -ne 0 ]; then
                    continue
                fi

                pr_number=$(echo "$pr_json" | jq -r '.number' 2>/dev/null)
                pr_title=$(echo "$pr_json" | jq -r '.title' 2>/dev/null)
                pr_state=$(echo "$pr_json" | jq -r '.state' 2>/dev/null)

                # Get the user's actual review submission dates
                review_dates=$(echo "$pr_json" | jq -r ".reviews[]? | select(.author.login == \"$GITHUB_USERNAME\") | .submittedAt" 2>/dev/null | cut -d'T' -f1)

                # Check if any review was submitted in our date range
                echo "$review_dates" | while read -r review_date; do
                    if [ -n "$review_date" ]; then
                        if [[ "$review_date" > "$START_DATE" || "$review_date" = "$START_DATE" ]] && [[ "$review_date" < "$END_DATE" || "$review_date" = "$END_DATE" ]]; then
                            echo "$pr_number"$'\t'"$pr_title"$'\t'"$pr_state"$'\t'"$REPO_NAME"$'\t'"$review_date"$'\t'"approved"
                            break
                        fi
                    fi
                done
            done

        # Method 2: PRs where user was involved (commented, requested changes, etc.)
        gh pr list --search "involves:$GITHUB_USERNAME -author:$GITHUB_USERNAME" \
            --limit 100 --state all --json number,title,state,reviews \
            2>/dev/null | jq -r ".[] | @base64" 2>/dev/null | while read -r pr_base64; do
                if [ -z "$pr_base64" ]; then
                    continue
                fi

                pr_json=$(echo "$pr_base64" | base64 -d 2>/dev/null)
                if [ $? -ne 0 ]; then
                    continue
                fi

                pr_number=$(echo "$pr_json" | jq -r '.number' 2>/dev/null)
                pr_title=$(echo "$pr_json" | jq -r '.title' 2>/dev/null)
                pr_state=$(echo "$pr_json" | jq -r '.state' 2>/dev/null)

                # Get the user's actual review submission dates
                review_dates=$(echo "$pr_json" | jq -r ".reviews[]? | select(.author.login == \"$GITHUB_USERNAME\") | .submittedAt" 2>/dev/null | cut -d'T' -f1)

                # Check if any review was submitted in our date range
                echo "$review_dates" | while read -r review_date; do
                    if [ -n "$review_date" ]; then
                        if [[ "$review_date" > "$START_DATE" || "$review_date" = "$START_DATE" ]] && [[ "$review_date" < "$END_DATE" || "$review_date" = "$END_DATE" ]]; then
                            echo "$pr_number"$'\t'"$pr_title"$'\t'"$pr_state"$'\t'"$REPO_NAME"$'\t'"$review_date"$'\t'"reviewed"
                            break
                        fi
                    fi
                done
            done
    done | sort -u > "$TEMP_REVIEWED" || echo "" > "$TEMP_REVIEWED"

    if [ -s "$TEMP_REVIEWED" ]; then
        # PRs are already filtered by actual review date, just format them
        TEMP_FILTERED=$(create_temp_file "filtered_reviewed")
        while IFS=$'\t' read -r number title state repo review_date review_type; do
            if [ -n "$number" ] && [ -n "$review_date" ]; then
                echo "$number"$'\t'"$title"$'\t'"$state"$'\t'"$repo"$'\t'"$review_date"$'\t'"$review_type" >> "$TEMP_FILTERED"
            fi
        done < "$TEMP_REVIEWED"
        
        if [ -s "$TEMP_FILTERED" ]; then
            # Group by PR number and collect all review dates for each PR
            TEMP_GROUPED=$(create_temp_file "grouped_reviews")

            # Sort by PR number and date, then process unique PRs
            sort -t$'\t' -k1,1n -k5,5 "$TEMP_FILTERED" | while IFS=$'\t' read -r number title state repo review_date review_type; do
                echo "$number"$'\t'"$title"$'\t'"$state"$'\t'"$repo"$'\t'"$review_date"
            done | sort -u -t$'\t' -k1,1n > "$TEMP_GROUPED"

            REVIEWED_COUNT=$(cat "$TEMP_GROUPED" | cut -f1 | sort -u | count_lines)
            echo "**Total PRs Reviewed:** $REVIEWED_COUNT" >> "$REPORT_FILE"
            echo "" >> "$REPORT_FILE"
            echo '```' >> "$REPORT_FILE"

            # Format PR data in codeblock matching commit style (single line)
            while IFS=$'\t' read -r number title state repo review_date; do
                clean_title=$(echo "$title" | sed 's/|/ /g')
                clean_repo=$(echo "$repo" | sed 's/.*\///')

                # Map state to emoji
                case "$state" in
                    "MERGED") state_icon="‚úì" ;;
                    "OPEN") state_icon="‚óã" ;;
                    "CLOSED") state_icon="‚úï" ;;
                    *) state_icon="‚Ä¢" ;;
                esac

                printf "‚îî‚îÄ %s | PR #%s [%s] %s %s %s\n\n" "$review_date" "$number" "$clean_repo" "$state_icon" "$state" "$clean_title" >> "$REPORT_FILE"
            done < "$TEMP_GROUPED"
            echo '```' >> "$REPORT_FILE"
            echo "" >> "$REPORT_FILE"
            rm -f "$TEMP_GROUPED"
        else
            echo "> No PRs reviewed during this period." >> "$REPORT_FILE"
            echo "" >> "$REPORT_FILE"
        fi
        rm -f "$TEMP_FILTERED"
    else
        echo "> No PRs reviewed during this period." >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"
    fi
    
    echo "### PRs Authored by Me" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    
    # Get PRs authored by user with detailed formatting - loop through each repository
    TEMP_AUTHORED=$(create_temp_file "authored")
    TEMP_PR_BRANCHES=$(create_temp_file "pr_branches")

    for REPO_PATH in "${REPO_PATHS[@]}"; do
        cd "$REPO_PATH"
        REPO_NAME=$(basename "$REPO_PATH")

        # Get authored PRs from this repository with branch info
        gh pr list --search "author:$GITHUB_USERNAME created:$START_DATE..$END_DATE" \
            --limit 100 --state all --json number,title,state,createdAt,headRefName \
            2>/dev/null | jq -r ".[] | [.number, .title, .state, \"$REPO_NAME\", .createdAt, .headRefName] | @tsv" 2>/dev/null >> "$TEMP_AUTHORED"
    done

    if [ -s "$TEMP_AUTHORED" ]; then
        # Count authored PRs first
        AUTHORED_COUNT=$(cat "$TEMP_AUTHORED" | count_lines)
        echo "**Total PRs Authored:** $AUTHORED_COUNT" >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"

        # Sort PRs by date and display as simple list
        sort -t$'\t' -k5 "$TEMP_AUTHORED" | while IFS=$'\t' read -r number title state repo created_at branch_name; do
            if [ -n "$number" ]; then
                clean_title=$(echo "$title" | sed 's/|/ /g')
                clean_repo=$(echo "$repo" | sed 's/.*\///')
                created_date=$(echo "$created_at" | cut -d'T' -f1)

                # Map state to emoji
                case "$state" in
                    "MERGED") state_icon="‚úì" ;;
                    "OPEN") state_icon="‚óã" ;;
                    "CLOSED") state_icon="‚úï" ;;
                    *) state_icon="‚Ä¢" ;;
                esac

                printf "- %s | PR #%s [%s] %s %s %s\n" "$created_date" "$number" "$clean_repo" "$state_icon" "$state" "$clean_title" >> "$REPORT_FILE"
            fi
        done

        echo "" >> "$REPORT_FILE"
    else
        echo "> No PRs authored during this period." >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"
    fi
    
    # Clean up temp files
    rm -f "$TEMP_REVIEWED" "$TEMP_AUTHORED"
    
else
    echo "### ‚ö†Ô∏è GitHub CLI Not Available" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "> GitHub CLI (\`gh\`) is not installed. PR review data cannot be extracted." >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "#### Installation Instructions" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    case "$OS_TYPE" in
        "windows")
            echo "- **Windows:** \`winget install GitHub.cli\` or \`choco install gh\`" >> "$REPORT_FILE"
            ;;
        "linux")
            echo "- **Linux:** \`sudo apt install gh\` or \`sudo snap install gh\`" >> "$REPORT_FILE"
            ;;
        "macos")
            echo "- **macOS:** \`brew install gh\`" >> "$REPORT_FILE"
            ;;
        *)
            echo "- Visit [GitHub CLI](https://cli.github.com/) for installation instructions" >> "$REPORT_FILE"
            ;;
    esac
    echo "- **All platforms:** Visit [https://cli.github.com/](https://cli.github.com/)" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
fi

cat >> "$REPORT_FILE" << EOF

---

## üìù Commits Summary

EOF

# Step 1: Extract commits from all repositories
echo "üìù Extracting commits from ${#REPO_PATHS[@]} repositories..."

# Initialize counters
TOTAL_COMMIT_COUNT=0

TEMP_COMMIT_STATS=$(create_temp_file "stats")
TEMP_DAY_STATS=$(create_temp_file "days")
TEMP_BRANCH_DATA=$(create_temp_file "branches")
TEMP_COMMIT_DETAILS=$(create_temp_file "details")

# Create author pattern for enhanced matching
AUTHOR_PATTERN=$(create_author_pattern "$AUTHOR" "$GITHUB_USERNAME")

# Process each repository
REPO_INDEX=0
for REPO_PATH in "${REPO_PATHS[@]}"; do
    REPO_INDEX=$((REPO_INDEX + 1))
    show_progress $REPO_INDEX ${#REPO_PATHS[@]} "Processing $(basename "$REPO_PATH")"
    
    cd "$REPO_PATH"
    git fetch --all >/dev/null 2>&1 || true
    
    # Get commit count using multiple author patterns (case-insensitive) - include all commits including from merged PRs
    REPO_COMMIT_COUNT_NAME=$(git log --all --full-history --author="$AUTHOR" --regexp-ignore-case --since="$START_DATE" --until="$END_DATE" --oneline 2>/dev/null | count_lines)
    REPO_COMMIT_COUNT_USERNAME=$(git log --all --full-history --author="$GITHUB_USERNAME" --regexp-ignore-case --since="$START_DATE" --until="$END_DATE" --oneline 2>/dev/null | count_lines)
    
    # Use the higher count (some commits might be under name, others under username)
    if [ "$REPO_COMMIT_COUNT_USERNAME" -gt "$REPO_COMMIT_COUNT_NAME" ]; then
        REPO_COMMIT_COUNT=$REPO_COMMIT_COUNT_USERNAME
        PRIMARY_AUTHOR="$GITHUB_USERNAME"
    else
        REPO_COMMIT_COUNT=$REPO_COMMIT_COUNT_NAME
        PRIMARY_AUTHOR="$AUTHOR"
    fi
    TOTAL_COMMIT_COUNT=$((TOTAL_COMMIT_COUNT + REPO_COMMIT_COUNT))
    
    if [ "$REPO_COMMIT_COUNT" -gt 0 ]; then
        # Find branches where user actually pushed commits during this date range
        USER_BRANCHES=$(find_user_branches "$REPO_PATH" "$PRIMARY_AUTHOR" "$START_DATE" "$END_DATE")
        
        # Store user branches for this repo in a temp file for later use
        echo "REPO:$(basename "$REPO_PATH")|BRANCHES:$USER_BRANCHES" >> "${TEMP_BRANCH_DATA}.user_branches"
        
        # Collect commit data for branch analysis - use comprehensive approach to capture ALL commits
        # This includes commits from merged PRs that might not appear in regular --all logs
        git log --all --full-history --author="$PRIMARY_AUTHOR" --regexp-ignore-case --since="$START_DATE" --until="$END_DATE" \
            --pretty=format:"%H|%ai|%s|%D|$(basename "$REPO_PATH")" 2>/dev/null >> "$TEMP_COMMIT_DETAILS"
        
        # Collect commit statistics using primary author (case-insensitive) - include all commits with full history
        git log --all --full-history --author="$PRIMARY_AUTHOR" --regexp-ignore-case --since="$START_DATE" --until="$END_DATE" \
            --pretty=format:"%ad" --date=short 2>/dev/null >> "$TEMP_COMMIT_STATS"
        git log --all --full-history --author="$PRIMARY_AUTHOR" --regexp-ignore-case --since="$START_DATE" --until="$END_DATE" \
            --pretty=format:"%ad" --date=format:"%A" 2>/dev/null >> "$TEMP_DAY_STATS"
    fi
done

# Return to original directory
if [ "$OS_TYPE" = "windows" ]; then
    # Windows Git Bash sometimes has issues with cd -
    cd "$(dirname "$0")" 2>/dev/null || true
else
    cd - >/dev/null 2>&1 || true
fi

# Remove duplicate commits and process them to organize by branch
echo "üåø Analyzing branch-based commit organization..."
if [ -s "$TEMP_COMMIT_DETAILS" ]; then
    # Remove duplicate commits based on hash (first field)
    sort "$TEMP_COMMIT_DETAILS" | uniq > "${TEMP_COMMIT_DETAILS}.tmp"
    mv "${TEMP_COMMIT_DETAILS}.tmp" "$TEMP_COMMIT_DETAILS"
    while IFS='|' read -r commit_hash commit_date commit_message branch_refs repo_name; do
        # Get the repository path for this commit
        REPO_PATH=""
        for repo in "${REPO_PATHS[@]}"; do
            if [ "$(basename "$repo")" = "$repo_name" ]; then
                REPO_PATH="$repo"
                break
            fi
        done
        
        # Get user branches for this repository
        USER_BRANCHES=""
        if [ -f "${TEMP_BRANCH_DATA}.user_branches" ]; then
            USER_BRANCHES=$(grep "^REPO:$repo_name|" "${TEMP_BRANCH_DATA}.user_branches" 2>/dev/null | cut -d'|' -f2 | sed 's/BRANCHES://')
        fi
        
        # Get the most likely branch where user worked on this commit
        if [ -n "$REPO_PATH" ] && [ -n "$USER_BRANCHES" ]; then
            clean_branch=$(get_user_work_branch "$commit_hash" "$REPO_PATH" "$USER_BRANCHES")
        elif [ -n "$REPO_PATH" ]; then
            # Fallback to original branch detection
            clean_branch=$(get_original_branch "$commit_hash" "$REPO_PATH")
        else
            # Fallback to parsing branch references
            clean_branch=$(parse_branch_name "$branch_refs")
        fi
        
        # Default to "main" if no branch detected
        if [ -z "$clean_branch" ]; then
            clean_branch="main"
        fi
        
        # Create branch name with repository for clarity
        branch_with_repo="${repo_name}/${clean_branch}"
        
        # Store branch association: branch_with_repo|commit_hash|date|message|repo
        echo "$branch_with_repo|$commit_hash|$commit_date|$commit_message|$repo_name" >> "$TEMP_BRANCH_DATA"
    done < "$TEMP_COMMIT_DETAILS"
fi


if [ "$TOTAL_COMMIT_COUNT" -gt 0 ]; then
    echo "### üåø Commits Organized by Branch" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    
    # Show branches where user actually pushed commits
    if [ -f "${TEMP_BRANCH_DATA}.user_branches" ]; then
        echo "#### üöÄ User's Active Branches (where commits were pushed)" >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"
        echo '```' >> "$REPORT_FILE"
        while IFS='|' read -r repo_info branches_info; do
            repo_name=$(echo "$repo_info" | cut -d':' -f2)
            user_branches=$(echo "$branches_info" | cut -d':' -f2)
            if [ -n "$user_branches" ]; then
                echo "Repository: $repo_name" >> "$REPORT_FILE"
                echo "$user_branches" | tr ' ' '\n' | while read branch; do
                    if [ -n "$branch" ]; then
                        echo "  üìå $branch" >> "$REPORT_FILE"
                    fi
                done
                echo "" >> "$REPORT_FILE"
            fi
        done < "${TEMP_BRANCH_DATA}.user_branches"
        echo '```' >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"
    fi
    
    if [ -s "$TEMP_BRANCH_DATA" ]; then
        # Group commits by branch
        echo "#### Commits Grouped by Branch Name" >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"
        
        # Get unique branches sorted by earliest commit date
        # Create temp file with branch name and earliest date
        TEMP_BRANCH_DATES=$(create_temp_file "branch_dates")
        cut -d'|' -f1 "$TEMP_BRANCH_DATA" | sort | uniq | while read -r branch; do
            if [ -n "$branch" ]; then
                # Get earliest commit date for this branch
                earliest_date=$(grep "^$branch|" "$TEMP_BRANCH_DATA" | cut -d'|' -f3 | sort | head -1)
                echo "$earliest_date|$branch" >> "$TEMP_BRANCH_DATES"
            fi
        done

        # Sort branches by date and extract branch names
        UNIQUE_BRANCHES=$(sort "$TEMP_BRANCH_DATES" | cut -d'|' -f2)
        BRANCH_COUNT=$(echo "$UNIQUE_BRANCHES" | wc -l | tr -d ' ')

        echo "**Total Branches:** $BRANCH_COUNT" >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"

        # Process each unique branch (sorted by date)
        echo "$UNIQUE_BRANCHES" | while read -r branch; do
            if [ -n "$branch" ]; then
                commit_count=$(grep "^$branch|" "$TEMP_BRANCH_DATA" | wc -l | tr -d ' ')

                # Get date range for this branch
                branch_commits=$(grep "^$branch|" "$TEMP_BRANCH_DATA" | cut -d'|' -f3 | sort)
                first_commit_date=$(echo "$branch_commits" | head -1 | cut -d' ' -f1)
                last_commit_date=$(echo "$branch_commits" | tail -1 | cut -d' ' -f1)

                # Determine branch status based on commit messages (merged PRs or active)
                branch_status="‚óã active"
                branch_name_only=$(echo "$branch" | cut -d'/' -f2-)

                # Check if any commit message indicates this was merged (contains PR merge pattern)
                if grep "^$branch|" "$TEMP_BRANCH_DATA" | cut -d'|' -f4 | grep -qiE "(#[0-9]+|merged|merge pull request)"; then
                    branch_status="‚úì merged"
                fi

                # Format date range display
                if [ "$first_commit_date" = "$last_commit_date" ]; then
                    date_range="$first_commit_date"
                else
                    date_range="$first_commit_date ‚Üí $last_commit_date"
                fi

                echo "##### üå± \`$branch\` ($commit_count commits) | $date_range | $branch_status" >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
                echo '```' >> "$REPORT_FILE"
                
                # Show commits for this branch in codeblock format with full details - sorted chronologically
                grep "^$branch|" "$TEMP_BRANCH_DATA" | sort -t'|' -k3 | while IFS='|' read -r b_branch b_hash b_date b_message b_repo; do
                    # Clean up data for codeblock display
                    short_hash=$(echo "$b_hash" | cut -c1-8)
                    full_hash="$b_hash"
                    clean_message=$(echo "$b_message" | sed 's/|/ /g')
                    date_time=$(echo "$b_date" | cut -d' ' -f1,2)
                    date_only=$(echo "$b_date" | cut -d' ' -f1)
                    
                    # Get commit type for statistics
                    commit_type=$(get_commit_type "$clean_message")
                    
                    # Get repository path for GitHub links
                    COMMIT_REPO_PATH=""
                    for repo in "${REPO_PATHS[@]}"; do
                        if [ "$(basename "$repo")" = "$b_repo" ]; then
                            COMMIT_REPO_PATH="$repo"
                            break
                        fi
                    done
                    
                    # Create GitHub link if available
                    github_link=""
                    if [ -n "$COMMIT_REPO_PATH" ]; then
                        github_link=$(create_commit_link "$full_hash" "$COMMIT_REPO_PATH")
                    fi
                    
                    # Display commit with better formatting
                    printf "‚îå‚îÄ %s\n" "$date_time" >> "$REPORT_FILE"
                    printf "‚îî‚îÄ %s\n\n" "$clean_message" >> "$REPORT_FILE"
                done
                echo '```' >> "$REPORT_FILE"
                echo "" >> "$REPORT_FILE"
            fi
        done
        
        
    else
        echo "> No branch data found in commit history." >> "$REPORT_FILE"
        echo "" >> "$REPORT_FILE"
    fi
    
else
    echo "### ‚ÑπÔ∏è No Commits Found" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
    echo "> No commits were found for this period across all configured repositories." >> "$REPORT_FILE"
    echo "> This could mean:" >> "$REPORT_FILE"
    echo "> - No development activity during this period" >> "$REPORT_FILE"
    echo "> - Author name/username mismatch in git configuration" >> "$REPORT_FILE"
    echo "> - Repository paths need to be updated" >> "$REPORT_FILE"
    echo "" >> "$REPORT_FILE"
fi

# Clean up temp files
rm -f "$TEMP_COMMIT_STATS" "$TEMP_DAY_STATS" "$TEMP_BRANCH_DATA" "$TEMP_COMMIT_DETAILS" "${TEMP_BRANCH_DATA}.user_branches" "$TEMP_BRANCH_DATES"

cat >> "$REPORT_FILE" << 'EOF'

---

*Generated by [Commit Chronicle](https://github.com/your-username/commit-chronicle) - Monthly Development Report Generator*
EOF

# Calculate execution time
END_TIME=$(date +%s)
EXECUTION_TIME=$((END_TIME - START_TIME))
MINUTES=$((EXECUTION_TIME / 60))
SECONDS=$((EXECUTION_TIME % 60))

echo "‚úÖ Report generated successfully!"
echo ""
echo "üìä Generation Statistics:"
echo "   ‚è±Ô∏è  Execution time: ${MINUTES}m ${SECONDS}s"
echo "   üìù Total commits: $TOTAL_COMMIT_COUNT"
echo "   üìÅ Repositories: ${#REPO_PATHS[@]}"
echo "   üìÇ Report location: $REPORT_FILE"
echo ""
echo "üìÑ Quick Actions:"
echo "   üìñ View report:     cat '$REPORT_FILE'"
echo "   üìã Copy to clipboard: cat '$REPORT_FILE' | pbcopy"
echo "   üìß Open in editor:   open '$REPORT_FILE'"
echo "   üåê Share via GitHub: Upload to a gist or repository"
echo ""
echo "üí° Tips:"
echo "   ‚Ä¢ Commit links are included for GitHub repositories"
echo "   ‚Ä¢ Commits are categorized by type (feat, fix, chore, etc.)"
echo "   ‚Ä¢ Use different date ranges for quarterly or yearly reports"

# Return to original directory
cd "$ORIGINAL_DIR"
}

# If script is executed directly (not sourced), run the function
# Check if the script is being executed directly rather than sourced
if [[ "${(%):-%N}" == "${0}" ]] || [[ "$0" == *"commit-chronicle" && "$0" != "-zsh" ]]; then
    commit_chronicle "$@"
fi